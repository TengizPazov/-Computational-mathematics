def find_n_for_accuracy(x: float, epsilon: float) -> int:
    """
    Находит минимальный номер n, начиная с которого член ряда Тейлора для sin(x)
    становится меньше или равен заданной точности epsilon.

    Args:
        x: Аргумент функции sin(x).
        epsilon: Требуемая точность.

    Returns:
        Минимальное n, для которого |x^(2n+1)/(2n+1)!| <= epsilon.
    """
    n = 0
    # Вычисляем первый член ряда (n=0): x^(1) / 1! = x
    current_term = abs(x)
    # Пока текущий член больше эпсилон, продолжаем искать
    while current_term > epsilon:
        n += 1
        # Рекуррентная формула для вычисления следующего члена из предыдущего:
        # Член для n: a_n = x^(2n+1) / (2n+1)!
        # Член для n-1: a_{n-1} = x^(2(n-1)+1) / (2(n-1)+1)! = x^(2n-1) / (2n-1)!
        # 
        # a_n / a_{n-1} = (x^(2n+1) / (2n+1)!) / (x^(2n-1) / (2n-1)!)
        #               = (x^(2)) / ((2n) * (2n+1))
        # 
        # Следовательно: a_n = a_{n-1} * (x^2) / ((2n) * (2n+1))
        
        # В цикле мы на шаг n вычисляем член, соответствующий индексу n.
        # Для этого используем член с предыдущего шага (который был для n-1).
        current_term = current_term * (x * x) / ( (2 * n) * (2 * n + 1) )
    
    return n
